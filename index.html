<!doctype html>
<html lang="en">
<head>
    <title>Podcast call recorder</title>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <style>
        body {
            padding-bottom: 60px;
        }
        #chosenAction {
            margin: 20px 0;
        }
        #chosenAction .btn {
            margin: 0 10px;
        }
        .container {
            margin-bottom: 20px;
        }
        #duration {
            margin: 15px 0;
            font-size: 1.2em;
        }
        .badge {
            padding: 8px 12px;
        }
        footer {
            margin-top: 40px;
            padding: 20px 0;
            border-top: 1px solid #ddd;
            text-align: center;
        }
        footer span {
            display: block;
            margin: 5px 0;
        }
        .modal-body p {
            margin-bottom: 15px;
        }
        .card {
            margin-bottom: 15px;
        }
        .btn-sm {
            margin: 0 5px;
        }
    </style>

</head>
<body>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" crossorigin="anonymous"></script>
<script src="https://pi.pe/iot/js/qrcode.js"></script>

<a href="index.html"><h1 id="title" class="text-center">Podcast interview recorder</h1></a>
<div class="container">
    <h2>Role:  <span class="badge badge-primary" id="role"></span></h2>
    <h2>Status: <span class="badge badge-primary" id="status"></span></h2>
</div>
<div class="container">
        <div id="chosenAction" class="row">
            <button id="mute" type="button" class="btn btn-primary btn-lg"><i id="muteIcon" class="fa fa-microphone fa-2x" aria-hidden="true"></i></button>
            <button id="stopCall" type="button" class="btn btn-primary btn-lg"><i id="stopIcon" class="fa fa-stop fa-2x" aria-hidden="true"></i></button>
            <button id="restartCall" type="button" class="btn btn-warning btn-lg" style="display: none;"><i id="restartIcon" class="fa fa-refresh fa-2x" aria-hidden="true"></i> Restart</button>
        </div>
    <div>Duration <span class="badge badge-error" id="duration"></span></div>
    <div class="alert alert-danger" id="packetLoss">
        <strong id="countZero"></strong>% packet loss detected.
    </div>
    <div class="alert alert-info" id="statsZone">
        local <strong id="local"></strong><br/>
        <strong id="delay"></strong> sec delay<br/>
        remote <strong id="remote"></strong><br/>
        <button id="viewCheckpoints" type="button" class="btn btn-sm btn-secondary mt-2">View Checkpoints</button>
    </div>
</div>

<div id="share" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Send this url to the interviewee. </h5>
            </div>
            <div class="modal-body" id="shareQR">
                <p>Share this URL to request an interview</p>
            </div>
            <div class="modal-footer">
                <button id="shareDone" type="button" class="btn btn-secondary" data-dismiss="modal" onclick="shared();">Done</button>
            </div>
        </div>
    </div>
</div>
<div id="restartConfirm" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Confirm Restart</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to clear the current recording and start over? This will delete any unsaved recordings.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmRestart">Yes, Clear and Restart</button>
            </div>
        </div>
    </div>
</div>
<div id="stopConfirm" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Confirm Stop</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to end the recording?</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmStop">Yes, Stop Recording</button>
            </div>
        </div>
    </div>
</div>
<div id="accept" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Accept an interview</h5>
            </div>
            <div class="modal-body">
                <p>Click 'accept' to start the call.</p>
            </div>
            <div class="modal-footer">
                <button id="callAccept" type="button" class="btn btn-secondary" data-dismiss="modal" onclick="accepted();">Accept</button>
            </div>
        </div>
    </div>
</div>
<div id="nowebrtc" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Sorry</h5>
            </div>
            <div class="modal-body">
                <p>Unfortunately the browser you are using does not support WebRTC.</p>
                <p>Please retry using Safari on iOS, Chrome on Android, FireFox on Android, or pretty much any modern browser on a laptop.</p>
            </div>
            <div class="modal-footer">
                <button id="sadder" type="button" class="btn btn-secondary" data-dismiss="modal" >Accept</button>
            </div>
        </div>
    </div>
</div>
<div id="nomediaapi" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Sorry</h5>
            </div>
            <div class="modal-body">
                <p>Unfortunately the browser you are using does not support the media recorder API.</p>
                <p>Please try hosting the call with Chrome or FireFox or Edge.</p>
                <p>Your guest can use any modern browser</p>
            </div>
            <div class="modal-footer">
                <button id="sad" type="button" class="btn btn-secondary" data-dismiss="modal" >Accept</button>
            </div>
        </div>
    </div>
</div>
<div id="facebookapp" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Sorry</h5>
            </div>
            <div class="modal-body">
                <p>Unfortunately the Facebook apps block webRTC.</p>
                <p>Please try hosting the call with Chrome or FireFox or Edge.</p>
                <p>Go to <pre>https://rendezvous.show/</pre> outside the Facebook or instagram app.</p>
                <p>You may be able to do this from the three dot menu on the top right of your screen.</p>
                <p>Your guest can use any modern browser e.g. Chrome or FireFox or Edge or Safari</p>
            </div>
            <div class="modal-footer">
                <button id="sader" type="button" class="btn btn-secondary" data-dismiss="modal" >Accept</button>
            </div>
        </div>
    </div>
</div>
<audio id="them" style="display: none" autoplay> </audio>
<video id="nosleep" width="100" playsinline muted>
    Antisleep video.
</video>
<footer><span>See our <a href="https://github.com/pipe/podcall">Github</a> for source code</span>
    <span>See also <a href="https://rendezvous.berlin/privacy-policy.html">Privacy</a>
       and <a href="https://pi.pe/Impressum/index.html">Impressum</a></span>
</footer>
<script>
var properties = {
websocketURL: "wss://pi.pe/websocket/?finger=" // where to find the redezvous server.
};



    var pc; // actual peer connection to our friend
    var socket; // used to set up connection with our peer.
    var mid;
    var fid;
    var cid;
    var myac;
    var initiator;
    var lcandyStash = [];
    var rcandyStash = [];
    var localStream;
    var dcomp;
    var recorder;
    var recorderHost;
    var recorderGuest;
    var chunks = [];
    var hostChunks = [];
    var guestChunks = [];
    var saved = false;
    var hostSaved = false;
    var guestSaved = false;
    var startRecTime = 0;
    var lastLoss = 0;
    var lastRecv =0;
    var softstereo = true;
    var join;

    // Checkpoint system
    var sessionId;
    var checkpointInterval;
    var lastCheckpointTime = 0;
    var checkpointDB;
    const CHECKPOINT_INTERVAL_MS = 60000; // 60 seconds


    var mute = false;
    var peerConnectionOfferAnswerCriteria =  {offerToReceiveAudio: true, offerToReceiveVideo: false };
    var AudioContext = window.AudioContext || window.webkitAudioContext;


    // message stuff - used to create direct connection to peer over WEBRTC

    function tweakSDP(sdp){
        var lines = sdp.split("\r\n");
        for (var i=0;i<lines.length;i++){
            line = lines[i];
            if (line.startsWith("a=fmtp:111")){
                lines[i]= "a=fmtp:111 minptime=10; ptime=60; useinbandfec=1";
            }
        }
        return (lines.join("\r\n"));
    }

function loadProps() {
    var that = {configUrl: "pipeconfig.json"};
    var promise = new Promise(function (resolve, reject) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', that.configUrl, true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == "200") {
                var pipeconfig = JSON.parse(xobj.responseText);
                console.log("Config is " + xobj.responseText);
                if (pipeconfig.ice) {
                    that.configuration = pipeconfig.ice;
                    console.log("Set ICE params " + JSON.stringify(that.configuration));
                }
                if (pipeconfig.wsurl) {
                    that.wsurl = pipeconfig.wsurl;
                    console.log("Set wsurl " + JSON.stringify(that.wsurl));
                }
                resolve(that);
            }
        };
        xobj.send(null);
    });
    return promise;
}
    function messageDeal(event){
        var lines = event.data.split("\n");
        console.log("message lines = ", lines.length);

        lines.forEach((line) => {
            var data = JSON.parse(line);
            console.log("message data is ", data);
            if (data.to != mid) {
                alert("message mixup");
            }
            switch (data.type) {
                case "offer":
                    if (fid == null) {
                        fid = data.from;
                    }
                    if (recorder && initiator) {
                        stopCall();
                        document.location = document.location;
                    } else {
                        pc.setRemoteDescription(data).then(_ =>
                            pc.createAnswer(peerConnectionOfferAnswerCriteria).then(ans => {
                                ans.sdp = tweakSDP(ans.sdp);
                                pc.setLocalDescription(ans).then(_ =>
                                    sendMessage(fid, mid, "answer", ans.sdp)
                                )
                            })
                        )
                            .catch((e) => console.log("set Remote offer error", e));
                    }
                    break;
                case "answer":
                    pc.setRemoteDescription(data)
                        .then(_ => {
                            //$("#action").text("hangup");
                        })
                        .catch(e => console.log("set Remote answer error", e));
                    break;
                case "candidate":
                    var jc = {
                        sdpMLineIndex: 0,
                        candidate: data.sdp
                    };
                    console.log("adding candidate ", jc);
                    var nc = new RTCIceCandidate(jc);
                    pc.addIceCandidate(nc)
                        .then(_ => console.log("added remote candidate"))
                        .catch((e) => console.log("couldn't add candidate ", e));
                    break;
            }
        });
    }

    function sendMessage(to,from,type,data){
        var messageJ = {
            to:to,
            from:from,
            type:type,
            sdp:data
        };

        var message = JSON.stringify(messageJ);
        console.log("sending ", messageJ);
        socket.send(message);
    }

    // button actions

    function startCall(cid){
        lcandyStash = [];
        rcandyStash = [];
        fid = cid;
        pc.createOffer(peerConnectionOfferAnswerCriteria)
            .then(desc => {
                console.log("offer created",);
                $("#status").text("Making call to host");
                desc.sdp = tweakSDP(desc.sdp);
                pc.setLocalDescription(desc).then( d => sendMessage(fid, mid, desc.type, desc.sdp));
            })
            .catch(e => console.log("offer not created due to ", e) );
    }
    function saveData(blob, suffix) {
        var fileName = 'distributedFuture-' + new Date().toISOString() + '-' + suffix + '.webm';

        console.log("Save data ?");
        var a = document.createElement("a");
        document.body.appendChild(a);
        a.style = "display: none";
        console.log("saving wav blob as " + fileName);
        url = window.URL.createObjectURL(blob);
        a.href = url;
        a.download = fileName;
        a.click();
        window.URL.revokeObjectURL(url);
        return fileName;
    }

    // IndexedDB Checkpoint functions
    function initCheckpointDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('PodCallCheckpoints', 1);
            request.onerror = () => reject('IndexedDB error');
            request.onsuccess = (e) => {
                checkpointDB = e.target.result;
                resolve(checkpointDB);
            };
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('checkpoints')) {
                    const store = db.createObjectStore('checkpoints', { keyPath: 'id', autoIncrement: true });
                    store.createIndex('sessionId', 'sessionId', { unique: false });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
            };
        });
    }

    function saveCheckpoint(hostBlob, guestBlob, duration) {
        if (!checkpointDB) return Promise.reject('DB not initialized');

        return new Promise((resolve, reject) => {
            const transaction = checkpointDB.transaction(['checkpoints'], 'readwrite');
            const store = transaction.objectStore('checkpoints');
            const index = store.index('sessionId');

            // Delete previous checkpoint for this session
            const deleteReq = index.openCursor(IDBKeyRange.only(sessionId));
            deleteReq.onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor) {
                    cursor.delete();
                    cursor.continue();
                }
            };

            // Add new checkpoint
            const checkpoint = {
                sessionId: sessionId,
                timestamp: Date.now(),
                hostBlob: hostBlob,
                guestBlob: guestBlob,
                duration: duration
            };
            const addReq = store.add(checkpoint);
            addReq.onsuccess = () => {
                console.log('Checkpoint saved');
                resolve();
            };
            addReq.onerror = () => reject('Failed to save checkpoint');
        });
    }

    function getCheckpoints() {
        return new Promise((resolve, reject) => {
            if (!checkpointDB) return reject('DB not initialized');
            const transaction = checkpointDB.transaction(['checkpoints'], 'readonly');
            const store = transaction.objectStore('checkpoints');
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject('Failed to get checkpoints');
        });
    }

    function deleteCheckpoint(id) {
        return new Promise((resolve, reject) => {
            if (!checkpointDB) return reject('DB not initialized');
            const transaction = checkpointDB.transaction(['checkpoints'], 'readwrite');
            const store = transaction.objectStore('checkpoints');
            const request = store.delete(id);
            request.onsuccess = () => resolve();
            request.onerror = () => reject('Failed to delete checkpoint');
        });
    }

    function downloadBlob(blob, suffix) {
        var a = document.createElement("a");
        document.body.appendChild(a);
        a.style = "display: none";
        var url = window.URL.createObjectURL(blob);
        a.href = url;
        a.download = 'distributedFuture-' + new Date(blob.timestamp || Date.now()).toISOString() + '-' + suffix + '.webm';
        a.click();
        window.URL.revokeObjectURL(url);
        a.remove();
    }

    // HTML escape function to prevent XSS
    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return unsafe;
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    function stopCall(){
        localStream.getAudioTracks()[0].stop();

        // Clear checkpoint interval
        if (checkpointInterval) {
            clearInterval(checkpointInterval);
        }

        if (initiator) {
            $("#status").text("Saving recordings...");
            // Stop both recorders
            if (recorderHost && recorderHost.state !== 'inactive') {
                recorderHost.stop();
            }
            if (recorderGuest && recorderGuest.state !== 'inactive') {
                recorderGuest.stop();
            }
        } else {
            clearInterval(recorder);
        }

        $("#status").text("Call ended.");

        // Show restart button
        $("#restartCall").show();

        // Show checkpoints modal
        showCheckpointsModal();
    }

    function restartCall(){
        // Clear the current recording and start over by reloading the page
        $("#restartConfirm").modal('hide');
        document.location = document.location;
    }

    function showCheckpointsModal() {
        getCheckpoints().then(checkpoints => {
            var modalHtml = '<div id="checkpointsModal" class="modal" tabindex="-1" role="dialog">' +
                '<div class="modal-dialog" role="document" style="max-width: 800px;">' +
                '<div class="modal-content">' +
                '<div class="modal-header">' +
                '<h5 class="modal-title">Recording Checkpoints</h5>' +
                '<button type="button" class="close" data-dismiss="modal" aria-label="Close">' +
                '<span aria-hidden="true">&times;</span>' +
                '</button>' +
                '</div>' +
                '<div class="modal-body">';

            if (checkpoints.length === 0) {
                modalHtml += '<p>No checkpoints available.</p>';
            } else {
                // Sort by timestamp descending (newest first)
                checkpoints.sort((a, b) => b.timestamp - a.timestamp);

                checkpoints.forEach(cp => {
                    var date = new Date(cp.timestamp);
                    var durationMins = Math.floor(cp.duration / 60000);
                    var durationSecs = Math.floor((cp.duration % 60000) / 1000);
                    // Escape all dynamic data to prevent XSS
                    var safeSessionId = escapeHtml(cp.sessionId ? cp.sessionId.substring(0, 16) : '');
                    var safeDateStr = escapeHtml(date.toLocaleString());
                    var safeDuration = escapeHtml(durationMins + ':' + String(durationSecs).padStart(2, '0'));
                    var safeId = escapeHtml(String(cp.id));

                    modalHtml += '<div class="card mb-3">' +
                        '<div class="card-body">' +
                        '<h6 class="card-title">Session: ' + safeSessionId + '...</h6>' +
                        '<p class="card-text">' +
                        '<small class="text-muted">Saved: ' + safeDateStr + '</small><br>' +
                        '<small class="text-muted">Duration: ' + safeDuration + '</small>' +
                        '</p>' +
                        '<button class="btn btn-sm btn-primary download-host" data-id="' + safeId + '">Download Host</button> ' +
                        '<button class="btn btn-sm btn-primary download-guest" data-id="' + safeId + '">Download Guest</button> ' +
                        '<button class="btn btn-sm btn-danger delete-checkpoint" data-id="' + safeId + '">Delete</button>' +
                        '</div>' +
                        '</div>';
                });
            }

            modalHtml += '</div>' +
                '<div class="modal-footer">' +
                '<button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>' +
                '</div>' +
                '</div>' +
                '</div>' +
                '</div>';

            // Remove existing modal if present
            $('#checkpointsModal').remove();

            // Add new modal
            $('body').append(modalHtml);

            // Bind click events
            $('.download-host').click(function() {
                var id = parseInt($(this).data('id'));
                var cp = checkpoints.find(c => c.id === id);
                if (cp) downloadBlob(cp.hostBlob, 'host');
            });

            $('.download-guest').click(function() {
                var id = parseInt($(this).data('id'));
                var cp = checkpoints.find(c => c.id === id);
                if (cp) downloadBlob(cp.guestBlob, 'guest');
            });

            $('.delete-checkpoint').click(function() {
                var id = parseInt($(this).data('id'));
                deleteCheckpoint(id).then(() => {
                    $('#checkpointsModal').modal('hide');
                    setTimeout(showCheckpointsModal, 300);
                });
            });

            $('#checkpointsModal').modal('show');
        }).catch(err => {
            console.error('Failed to load checkpoints:', err);
        });
    }



    // mute management
    function setMute(m){
        var mi = $("#muteIcon");
        mute = m;
        if (m){
            mi.removeClass("fa-microphone");
            mi.addClass("fa-microphone-slash");
        } else {
            mi.removeClass("fa-microphone-slash");
            mi.addClass("fa-microphone");
        }
        var audioTracks = localStream.getAudioTracks();
        if (audioTracks[0]) {
            audioTracks[0].enabled = !m;
        }
    }

    function repaintDuration(){
        var diff = Date.now() - startRecTime;
        console.log ("data on at "+diff);
        var mins = Math.floor(diff / 60000);
        var secs = Math.floor((diff % 60000) / 1000);
        $("#duration").text(""+mins+":"+secs);
    }
    function checkLoss(){
        pc.getReceivers()[0].getStats().then(
            function(rs) {
                rs.forEach( function (d){
                        if(d.type ==="inbound-rtp"){
                            var recvd = d.packetsReceived;
                            var lost = d.packetsLost;
                            if (lost > lastLoss){
                                $("#packetLoss").show();
                                var diffl = lost - lastLoss;
                                var diffp = recvd -lastRecv;
                                var pct = Math.ceil(100.0 * diffl /diffp);
                                $("#countZero").text(""+pct);
                            } else {
                                $("#packetLoss").hide();
                            }
                            lastLoss = lost;
                            lastRecv = recvd;
                        }
                        if ((d.type ==="candidate-pair")&&(d.nominated)){
                            $("#delay").text(""+d.currentRoundTripTime);
                        }
                        if (d.type === "remote-candidate"){
                            $("#remote").text(d.candidateType);
                        }
                        if (d.type === "local-candidate"){
                            $("#local").text(d.candidateType);
                        }
                    }
                )
            });
    }

    // called when webRTC presents us with a fresh remote audio stream
    function addStream(stream,kind) {
        if (!kind) {
            kind = "audio/video";
        }
        $("#status").text("Call connected.");

        console.log("got new stream" + stream + " kind =" + kind);
        if (kind.indexOf("audio")!= -1) {
            document.getElementById("them").srcObject = stream;
            var peer = myac.createMediaStreamSource(stream);

            // Generate session ID for this recording
            sessionId = 'session-' + Date.now();

            if (initiator) {
                // Create separate recording destinations for host and guest tracks
                var recStreamHost = myac.createMediaStreamDestination();
                var recStreamGuest = myac.createMediaStreamDestination();

                // Connect guest (remote) audio to guest recorder
                peer.connect(recStreamGuest);

                // Setup host recorder (local microphone)
                // The local stream source is already connected to dcomp in setupAudio
                // We need to also connect it to recStreamHost
                var localNode = myac.createMediaStreamSource(localStream);
                localNode.connect(recStreamHost);

                // Create host recorder
                recorderHost = new MediaRecorder(recStreamHost.stream);
                recorderHost.ondataavailable = function(evt) {
                    hostChunks.push(evt.data);
                    repaintDuration();
                };
                recorderHost.onstop = function(evt) {
                    var blob = new Blob(hostChunks, { 'type' : 'audio/webm; codecs=opus' });
                    var fileName = saveData(blob, 'host');
                    hostSaved = true;
                    console.log("Host track saved: " + fileName);

                    // Save as final checkpoint
                    var duration = Date.now() - startRecTime;
                    if (guestSaved) {
                        saveCheckpoint(blob, new Blob(guestChunks, { 'type' : 'audio/webm; codecs=opus' }), duration);
                    }
                };

                // Create guest recorder
                recorderGuest = new MediaRecorder(recStreamGuest.stream);
                recorderGuest.ondataavailable = function(evt) {
                    guestChunks.push(evt.data);
                    repaintDuration();
                };
                recorderGuest.onstop = function(evt) {
                    var blob = new Blob(guestChunks, { 'type' : 'audio/webm; codecs=opus' });
                    var fileName = saveData(blob, 'guest');
                    guestSaved = true;
                    console.log("Guest track saved: " + fileName);

                    // Save as final checkpoint
                    var duration = Date.now() - startRecTime;
                    if (hostSaved) {
                        saveCheckpoint(new Blob(hostChunks, { 'type' : 'audio/webm; codecs=opus' }), blob, duration);
                    }
                };

                stream.onremovetrack = function(event) {
                    console.log( "Removed track : " + event.track.kind + ": " + event.track.label);
                };

                // Start both recorders
                recorderHost.start(10000);
                recorderGuest.start(10000);

                // Set up checkpoint interval (every 60 seconds)
                checkpointInterval = setInterval(function() {
                    if (hostChunks.length > 0 || guestChunks.length > 0) {
                        var duration = Date.now() - startRecTime;
                        var hostBlob = new Blob(hostChunks, { 'type' : 'audio/webm; codecs=opus' });
                        var guestBlob = new Blob(guestChunks, { 'type' : 'audio/webm; codecs=opus' });
                        saveCheckpoint(hostBlob, guestBlob, duration);
                        console.log("Checkpoint saved at " + duration + "ms");
                        $("#status").text("Recording... Checkpoint saved (" + Math.floor(duration/60000) + ":" + String(Math.floor((duration%60000)/1000)).padStart(2,'0') + ")");
                    }
                }, CHECKPOINT_INTERVAL_MS);

                // Set onbeforeunload immediately when recording starts
                window.onbeforeunload = function() {
                    if (!hostSaved || !guestSaved) {
                        return "Recording in progress. If you leave this page, you will lose the audio files.";
                    }
                    return null;
                };

            } else {
                recorder = window.setInterval(repaintDuration,10000);
            }
            window.setInterval(checkLoss,1000);

            startRecTime = Date.now();

            // audio together here.
            // depends on role
            console.log('Audio sample Rate is '+ myac.sampleRate);
            $("#chosenAction").show();
            $("#statsZone").show();
        }
    }

    // configure local peerconnection and handlers
    function setupRTC(){
        pc = new RTCPeerConnection(properties.configuration, null);
        console.log("created peer connection");

        pc.onicecandidate = (e) => {
            console.log("local ice candidate", e.candidate);
            if (e.candidate != null) {
                if (pc.signalingState == 'stable') {
                    sendMessage(fid, mid, "candidate", e.candidate.candidate);
                } else {
                    console.log("stashing ice candidate");
                    lcandyStash.push(e.candidate);
                }
            }
        };
        pc.oniceconnectionstatechange = (e) => {
            console.log("ice state is changed", pc.iceConnectionState);
            /*
             "new"	The ICE agent is gathering addresses or is waiting to be given remote candidates through calls to RTCPeerConnection.addIceCandidate() (or both).
             "checking"	The ICE agent has been given one or more remote candidates and is checking pairs of local and remote candidates against one another to try to find a compatible match, but has not yet found a pair which will allow the peer connection to be made. It's possible that gathering of candidates is also still underway.
             "connected"	A usable pairing of local and remote candidates has been found for all components of the connection, and the connection has been established. It's possible that gathering is still underway, and it's also possible that the ICE agent is still checking candidates against one another looking for a better connection to use.
             "completed"	The ICE agent has finished gathering candidates, has checked all pairs against one another, and has found a connection for all components.
             "failed"	The ICE candidate has checked all candidates pairs against one another and has failed to find compatible matches for all components of the connection. It is, however, possible that the ICE agent did find compatible connections for some components.
             "disconnected"	Checks to ensure that components are still connected failed for at least one component of the RTCPeerConnection. This is a less stringent test than "failed" and may trigger intermittently and resolve just as spontaneously on less reliable networks, or during temporary disconnections. When the problem resolves, the connection may return to the "connected" state.
             "closed"
             */
            if (pc.iceConnectionState === "failed"){
                stopCall();
            }
        };
        // specification of WEBRTC is in flux - so we test to see if ontrack callback exists
        if ('ontrack' in pc) {
            // if so we use it
            pc.ontrack = (event) => {
                var stream = event.streams[0];
                console.log("got remote track ", event.track.kind);
                addStream(stream,event.track.kind);
            };
        } else {
            // if not we use add stream instead
            pc.onaddstream = (event) => {
                var stream = event.stream;
                console.log("got remote stream ", stream.kind);
                addStream(stream);
            }
        }

        // use this to determine the state of the 'hangup' button and send any candidates we found quickly
        pc.onsignalingstatechange = (evt) => {
            console.log("signalling state is ", pc.signalingState);
            if (pc.signalingState == 'stable') {
                var can;
                while (can = lcandyStash.pop()) {
                    console.log("popping candidate off stash")
                    sendMessage(fid, mid, "candidate", can.candidate);
                }
                var act = $("#stopCall");
                act.click( _ => $("#stopConfirm").modal('show') );
                $("#confirmStop").click( _ => {
                    $("#stopConfirm").modal('hide');
                    stopCall();
                });
            }
        };
    }


    // plumb the local audio together.
function setupAudio() {

    myac = new AudioContext();
    setNoSleep();
    dcomp = myac.createDynamicsCompressor();

    var gumConstraints = {audio: true, video: false};

    var promise = new Promise(function (resolve, reject) {
        navigator.mediaDevices.getUserMedia(gumConstraints)
            .then((stream) => {
                localStream = stream;
                if (initiator) {
                    let node = myac.createMediaStreamSource(stream);
                    if (softstereo){
                        let panme = myac.createStereoPanner();
                        panme.pan.value = -0.3;
                        node.connect(panme);
                        panme.connect(dcomp);
                    } else {
                        let splitme = myac.createChannelSplitter(2); // 2 outputs L and R
                        join = myac.createChannelMerger(2); // nominally 2 inputs L and R
                        node.connect(splitme);
                        splitme.connect(join, 0, 0)
                        join.connect(dcomp);
                    }
                }
                if (pc.addTrack) {
                    stream.getTracks().forEach(track => {
                        pc.addTrack(track, stream);
                        console.log("added local track ", track.id, track.kind);
                    });
                } else {
                    pc.addStream(stream);
                    console.log("added local stream");
                }
                resolve(false);
            })
            .catch((e) => {
                console.log('getUserMedia() error:' + e);
                reject(e);
            });
    });
    return promise;

}



function shared() {
    setupRTC();
    setupAudio().then(_ => {
        console.log("ready for offer");
        $("#status").text("Waiting for guest.");
    });
}
function accepted() {
    setupRTC();
    setupAudio().then(_ => {
        console.log("ready for offer");
        $("#status").text("Mic available");
        startCall(cid)
    });
}
// decide who we are initiator or recpient.
// notice that the actual call goes in the reverse direction
// the recipient of the invite actually creates the audiobearing peerconnection
// the initiator then accepts this audio - This allows the initiator the chance to
// change their mind, if their circumstances have changed since the invite was sent.

    function setRole() {
        cid = $.getUrlVar("podcastId");
        mid = localStorage['podcastId'];
        //var act = $("#action");
        if (!mid) {
            var array = new Uint32Array(8);
            window.crypto.getRandomValues(array);
            var hexCodes = [];
            for (var i = 0; i < array.length; i ++ ){
                // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)
                var value = array[i];
                // toString(16) will give the hex representation of the number without padding
                var stringValue = value.toString(16);
                // We use concatenation and slice for padding
                var padding = '00000000';
                var paddedValue = (padding + stringValue).slice(-padding.length)
                hexCodes.push(paddedValue);
            }
            mid = hexCodes.join("").toLowerCase();
            console.log("mid =", mid);
            localStorage['podcastId'] = mid;
        }
        if (cid == null){
            document.location = location.pathname + "?" + "podcastId=" + mid ;
            // this has the effect of getting our id into the browser bar -
            // making it easy to share etc.
        } else {
            var qrcode = new QRCode(document.getElementById("shareQR"), {
                width: 280,
                height: 280,
                correctLevel: QRCode.CorrectLevel.L
            });
            socket = new WebSocket( properties.wsurl + mid);
            socket.onmessage = messageDeal;
            socket.onopen = (_) => {
                var url = document.location.href;
                console.log("href = "+url);
                if (url) {
                    qrcode.makeCode(url);
                }
                initiator = (mid === cid);
                var smodal;
                if (initiator && !window.MediaRecorder) {
                    smodal ="#nomediaapi";
                } else {
                    $("#role").text(initiator ? "Host" : "Guest");
                    $("#status").text("Waiting for connection");
                    smodal = initiator ? "#share" : "#accept";
                }
                $(smodal).modal('show');
            };
            socket.onerror = (e) => {
                console.log("can't open websocket", e);
                $("#status").text("Internet problems ?");

            };
            socket.onclose = (e) => {
                console.log(" websocket closed", e);
                $("#status").text("Server problems ?");

            };

        }
    }

function _addSourceToVideo(element, type, dataURI) {
    var source = document.createElement('source');
    source.src = dataURI;
    source.type = 'video/' + type;
    element.appendChild(source);
}
/* find the original at https://github.com/richtr/NoSleep.js/ */
/* brutally butchered version of the above keeps the phone from sleeping becuase it sees a video playing...*/
    function setNoSleep() {
        var videoEl = document.getElementById("nosleep");
        _addSourceToVideo(videoEl, 'webm', 'data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=');
        _addSourceToVideo(videoEl, 'mp4', 'data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQAD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');
        videoEl.addEventListener('loadedmetadata', function () {
            console.log("loaded metadata");
            if (videoEl.duration <= 1) {
                // webm source
                videoEl.setAttribute('loop', '');
            } else {
                // mp4 source
                videoEl.addEventListener('timeupdate', function () {
                    if (videoEl.currentTime > 0.5) {
                        videoEl.currentTime = Math.random();
                    }
                });
            }
        });
        videoEl.play();
    }
function isFacebookApp() {
    var ua = navigator.userAgent || navigator.vendor || window.opera;
    return (ua.indexOf("FBAN") > -1) || (ua.indexOf("FBAV") > -1) || (ua.indexOf('Instagram') > -1) ;
}
function isWebrtcSupported() {
    // tip of the hat to Janus for this test :
    // https://groups.google.com/forum/#!topic/meetecho-janus/lRjYn0C9BYU
    // it should detect the horrible mess that is chrome on ios
    // and various other ugly captives....

    return ('RTCPeerConnection' in window) && ("mediaDevices" in navigator) && ("getUserMedia" in navigator.mediaDevices);
};
    // some housekeeping

    $.extend({
        getUrlVars: function(){
            var vars = [], hash;
            var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
            for(var i = 0; i < hashes.length; i++)
            {
                hash = hashes[i].split('=');
                vars.push(hash[0]);
                vars[hash[0]] = hash[1];
            }
            return vars;
        },
        getUrlVar: function(name){
            return $.getUrlVars()[name];
        }
    });

    $( document ).ready( _ => {
        $("#chosenAction").hide();
        $("#packetLoss").hide();
        $("#statsZone").hide();

        // Initialize checkpoint database
        initCheckpointDB().then(() => {
            console.log("Checkpoint DB initialized");
            $("#viewCheckpoints").click(showCheckpointsModal);
        }).catch(err => {
            console.error("Failed to initialize checkpoint DB:", err);
        });

        if (isFacebookApp()){
            $("#status").text("Facebook apps block webrtc in their 'browser' ");
            $("#facebookapp").show();
            console.log("UGH, facebook. !");
        } else {
            if (isWebrtcSupported()) {
                console.log("I see webRTC !");
                $("#status").text("Have webRTC available ");
                $("#mute").click(_ => setMute(!mute));
                $("#restartCall").click(_ => $("#restartConfirm").modal('show'));
                $("#confirmRestart").click(_ => restartCall());
                loadProps().then((props) => {
                    properties = props;
                    setRole();
                })


            } else {
                console.log("I don't see webRTC !");
                $("#status").text("Dont have webRTC available ");
                $('#nowebrtc').modal('show');
            }
        }


    });
</script>
</body>
</html>
